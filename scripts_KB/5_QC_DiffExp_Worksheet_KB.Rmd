---
title: "KIRC: Differential Analysis" 
author: "Katya Benard"
date: "April 2023"
output: 
  html_document: 
    keep_md: yes 
    toc: true  
    toc_depth: 4
    toc_float: 
      collapsed: false 
      smooth_scroll: true
    theme: flatly  
    highlight: haddock
---

***

### 0.0 Introduction  

After going through my own LIHC analysis, I realized that the filtering method of `expression >= 1 in all 10 fetal smaples` that we've used is too stringent. We're going to redo the filtering and normalization for both clusters, and then proceed with differential analysis. 

### 1.0 Loading Packages and Data  

Loading all of our packages:  

```{r packages, error=FALSE, message=FALSE, warning=FALSE, results='hide'}

# rmarkdown packages
library(knitr) 
library(rmarkdown)

# data wrangling packages
library(tidyverse)
library(janitor)

# data loading packages
library(readxl) 
library(openxlsx)
library(here)


# setting global script options - i.e, parameters/arguents that will be applied to all chunks, without having to explicity specify them each time
knitr::opts_chunk$set(warning = FALSE, message = FALSE, error = FALSE)

```

Reading in data:  

```{r data}
pDat <- read_excel(here::here("data", "KIRC_pDat_replicates_removed.xlsx"))
eDat <- read_rds(here::here("data", "KIRC_eDat_replicates_removed.RDS"))
mDat <- read_rds(here::here("data", "KIRC_mDat.RDS"))
 
# write_rds(mDat, "KIRC_mDat.RDS")

```

**Add your choice of font available at [Google Fonts](https://fonts.google.com/), and make your own customized ggplot2 theme**. We will now use this theme option for all future plots  

```{r theme-and-colpal}

library(showtext)
library(extrafont)
knitr::opts_chunk$set(fig.showtext = TRUE, fig_retina = 1) # needed to render show_text


font_add_google("Open Sans", "Sans")
# 
# colpal <- list(Condition = c(`Fetal` = "#ECB576", `NM` = "#115363", `Tumour` = "#A34237"),
#                Sex = c(`Male` = "#E05D5D", `Female` = "#ffb708"),
#                Self_reported_race = c(`Black or African American` = "#9BBC49", 
#                                       `Asian` = "#5B8D33", 
#                                       `White` = "#286E16", 
#                                       `Not Reported` = "#666666"))

colpal <- list(Condition = c(`Fetal` = "#4D6DA0", `NM` = "#72B592", `Tumour` = "#C5E3AA"),
               Sex = c(`Male` = "#9dba8f", `Female` = "#edcba0"),
               Self_Reported_Race = c(`African American or Black` = "#698ECF", `American Indian or Alaska Native` = "#565199", `Asian` = "#E26E51", `Caucasian or White` = "#F6D076", `Not Reported/Unknown` = "#de425b"), 
               Self_reported_race = c(`Black or African American` = "#698ECF", `American Indian or Alaska Native` = "#565199", `Asian` = "#E26E51", `White` = "#F6D076", `Not Reported` = "#de425b"), category= c('50-55' = "#003f5c", '55-60' = "#2f4b7c", '60-65'="#665191", '65-70'="#a05195", '70-75'="#d45087", '75-80'="#f95d6a", '80-85'="#ff7c43", '85-90'="#ffa600", '90-95'="#F6D076", '95-100'="#C5E3AA"))



my_theme <- theme_minimal() +
  theme(plot.title = element_text(family = "Sans", size = 14),
        plot.subtitle = element_text(family = "Sans", size = 12),
        legend.text = element_text(family = "Sans", size = 10),
        axis.title = element_text(family = "Sans", size = 14),
        axis.text = element_text(family = "Sans", size = 12))


# needed to bind ggplot and our custom font
showtext_auto()

```

***

### 2.0 Formatting  

**Make `eDat_long` as in the previous script, which contains the log2(x+1) expression data and phenotypic data all in one dataframe**  

```{r eDat-long}

eDat_long <- eDat %>% 
  pivot_longer(cols = -c(precursor, miRNA), names_to = "Sample", values_to = "Reads") %>% 
  left_join(pDat, by = "Sample") %>% 
  mutate(log2Reads = log2(Reads + 1))

```

***

### 3.0 Redoing filtering and normalization

#### 3.1 Filtering

**Based on the previous `4_QC` script, starting with our raw data, I want you to filter out miRNAs which have expression = 0 in all samples**  

```{r fil-0}

eDat <- eDat %>% 
  unite("mirs", c(precursor, miRNA), sep = ":") %>% 
  column_to_rownames("mirs")

eFil_0 <- eDat %>% 
   filter(if_any(everything(), ~ .x > 0))

dim(eFil_0)
# [1] 2739  565


```

> **CHECKPOINT:** Your `eFil_0` df should have 2739 rows and 565 columns  

**Remove mature miRNAs with duplicate expression**  

```{r efil}

eFil_0<- eFil_0 %>% 
  rownames_to_column("miRNA")

eFil_0 <- eFil_0 %>% 
  dplyr::rename ("mirs" = "miRNA")

eFil_0 %>% 
  separate(mirs, c("precursor", "miRNA"), sep = ":") %>%
  dplyr::count(miRNA) %>% # count the frequency of mature miRNAs
  filter(n > 1) # filter to keep only the ones which have a count of more than 1

eFil <- eFil_0 %>% 
  separate(mirs, c("precursor", "miRNA"), sep = ":") %>% 
  mutate(Sum = rowSums(select_if(., is.numeric))) %>% 
  group_by(miRNA) %>% 
  slice_max(Sum) %>% 
  dplyr::select(-Sum, -precursor) %>%
  distinct(miRNA, .keep_all = TRUE) %>%
  column_to_rownames("miRNA")

eDat <- eDat %>% 
  rownames_to_column("miRNA")
# split miRNA column in eDat to mirna and precursor 
# re-left join eFil and eDat
 eDat <- eDat %>% 
   separate(miRNA, c("precursor", "miRNA"), sep = ":")

dim(eFil)
#220 duplicated expected
#2519 565 produced 

```

> **CHECKPOINT:** Your `eFil` df should have 2519 rows and 565 columns  


**Make separate eFils and pDats per KIRC cluster and by fetal, and join the fetal samples to both cluster 1 and cluster 2**

```{r clusters}
#make matrix for eFil long
eFil<- eFil %>% 
  rownames_to_column("miRNA")

library(dplyr)

filtered_mature_df = data.frame(matrix(nrow = 2519, ncol = 1))
filtered_mature_df$matrix.nrow...2519..ncol...1.<- eFil$miRNA
colnames(filtered_mature_df) <- c("target")
require(dplyr)
data <- semi_join(eDat,filtered_mature_df, by = c(miRNA = "target"))
row.names(data) <- data$gene


data2 <- data %>% 
  mutate(Sum = rowSums(select_if(., is.numeric))) %>% 
  group_by(miRNA) %>% 
  slice_max(Sum) %>% 
  dplyr::select(-Sum, -precursor) %>%
  distinct(miRNA, .keep_all = TRUE) %>%
  column_to_rownames("miRNA")

dim(data2)

#2519 565

#make eFil_long

data2<- data2 %>% 
  rownames_to_column("miRNA")

eFil_long <- data2 %>% 
  pivot_longer(cols = -c(miRNA), names_to = "Sample", values_to = "Reads")

eFil_long_2 <- eFil_long %>% 
  left_join(pDat, by = "Sample")

eFil_long_2 <- eFil_long_2 %>% 
  mutate(log2Reads = log2(Reads + 1))

#------------------------------------------------------------------

pDat %>% 
  dplyr::count(cluster_group)

# fetal filtered
pDat_fetal <- pDat %>% 
    filter(Condition == "Fetal")
  
eFil_fetal <-eFil_long_2 %>%
  filter(Condition == "Fetal")

# cluster 1 filtered

pDat_cluster_1 <- pDat %>%
  filter(cluster_group == 1)

eFil_cluster_1 <- eFil_long_2 %>%
  filter(cluster_group == 1)

# cluster 2 filtered

pDat_cluster_2 <- pDat %>%
  filter(cluster_group ==2)

eFil_cluster_2 <- eFil_long_2 %>%
  filter(cluster_group == 2)

# joining fetal and c1

eFil_c1_fetal <- rbind(eFil_cluster_1,eFil_fetal)

pDat_c1_fetal <- rbind(pDat_cluster_1, pDat_fetal)
#has 289 samples
  
# joining fetal and c2
eFil_c2_fetal <- rbind(eFil_cluster_2,eFil_fetal)

pDat_c2_fetal <- rbind(pDat_cluster_2, pDat_fetal)
#has 286 samples

#eDat or eFil?
  
```

> **CHECKPOINT: You should have 289 samples in eDat_c1_fetal, and 286 samples in eDat_c2_fetal**  


#### 3.2 Normalization

**Normalize filtered dataframe for both cluster groups**

```{r norm}
#BiocManager::install("DESeq2")
#install.packages(DESeq2)
library(DESeq2)

#BiocManager::install("edgeR")
#install.packages(edgeR)
library(edgeR)

filtered_mirna_names <- as.data.frame(row.names(eFil)) 

eDat_matrix <- data2 %>% 
  column_to_rownames("miRNA") %>% 
  as.matrix()

eNorm <- as.data.frame(row.names(eDat_matrix))

all_cols <- colnames(eDat_matrix)

c1_fetal_cols <- all_cols[colnames(eDat_matrix) %in% pDat_c1_fetal$Sample]
c2_fetal_cols <- all_cols[colnames(eDat_matrix) %in% pDat_c2_fetal$Sample]

# Create new data frames
c1_fetal_matrix <- eDat_matrix %>% 
  as.data.frame() %>% 
  dplyr::select(c1_fetal_cols)

c2_fetal_matrix <- eDat_matrix %>% 
  as.data.frame() %>% 
  dplyr::select(c2_fetal_cols)

# cluster 1
samples_cluster_1 <- pDat_c1_fetal$Sample

norm_c1 <- DGEList(counts = c1_fetal_matrix, samples = pDat_c1_fetal$Sample, genes = eNorm)

# norm_counts_c1 <- DGEList(genes = filtered_mirna_names, 
#                           counts = eFil_c1_fetal, 
#                           samples = samples_cluster_1)

norm_c1 <- calcNormFactors(norm_c1, method = "RLE")

head(norm_c1[["samples"]])

eNorm_c1 <- cpm(norm_c1)

#eNorm_c1 <- log2(eNorm_c1 + 1)

eNorm_c1 <- round(eNorm_c1, digits = 0)

eNorm_c1 <- as.data.frame(eNorm_c1)
#------------------------------------------------------------------------------
# norm_counts_c1 <- calcNormFactors(norm_counts_c1, method = "RLE")
# 
# head(norm_counts_c1[["samples"]]) 
# 
# eNorm_c1 <- cpm(norm_counts_c1)
# 
# eNorm_c1 <- log2(eNorm_c1 + 1) 
# 
# eNorm_c1 <- round(eNorm_c1, digits = 0)
# 
# eNorm_c1 <- as.data.frame(eNorm_c1)


# cluster 2
samples_cluster_2 <- pDat_c2_fetal$Sample

norm_c2 <- DGEList(counts = c2_fetal_matrix, samples = pDat_c2_fetal$Sample, genes = eNorm)

norm_c2 <- calcNormFactors(norm_c2, method = "RLE")

head(norm_c2[["samples"]]) 

eNorm_c2 <- cpm(norm_c2)

#eNorm_c2 <- log2(eNorm_c2 + 1)

eNorm_c2 <- round(eNorm_c2, digits = 0)

eNorm_c2 <- as.data.frame(eNorm_c2)

```


**Make density and boxplots for raw normalized data, and display all plots together (you should have a total of 6 plots)** 

```{r norm-plots, fig.width=12, fig.height=9}

library(ggpubr)

eNorm_c1 <- eNorm_c1 %>% 
  rownames_to_column("miRNA")
  
eNorm_c1_long <- eNorm_c1 %>%
  pivot_longer(cols = -c(miRNA), names_to = "Sample", values_to = "Reads")

eNorm_c1_long <- eNorm_c1_long %>% 
  left_join(pDat_c1_fetal, by = "Sample")

eNorm_c1_long <- eNorm_c1_long %>% 
  mutate(log2Reads = log2(Reads + 1))

eNorm_c2 <- eNorm_c2 %>% 
  rownames_to_column("miRNA")

eNorm_c2_long <- eNorm_c2 %>%
  pivot_longer(cols = -c(miRNA), names_to = "Sample", values_to = "Reads")

eNorm_c2_long <- eNorm_c2_long %>% 
  left_join(pDat_c2_fetal, by = "Sample")

eNorm_c2_long <- eNorm_c2_long %>% 
  mutate(log2Reads = log2(Reads + 1))

# density
d1 <- eDat_long %>% 
  ggplot(aes(x = log2Reads, fill = Condition, colour = Condition)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("#de425b","#698ECF","#72B592")) +
  # scale_colour_manual(values = colpal$Condition) +
  labs(title = "KIRC: Raw Expression Data (eDat) ", y = "log2Reads") +
  theme_minimal() 

  
d2 <- eNorm_c1_long %>% 
  ggplot(aes(x = log2Reads, fill = Condition, colour = Condition)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("#de425b","#698ECF","#72B592")) +
  # scale_colour_manual(values = colpal$Condition) +
  labs(title = "KIRC: C1 Normalized Expression Data", y = "Density") +
  theme_minimal()


d3 <- eNorm_c2_long %>% 
  ggplot(aes(x = log2Reads, fill = Condition, colour = Condition)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("#de425b","#698ECF","#72B592")) +
  # scale_colour_manual(values = colpal$Condition) +
  labs(title = "KIRC: C2 Normalized Expression Data", y = "Density") +
  theme_minimal()

# boxplot
b1 <-eDat_long %>% 
  ggplot(aes(x = Condition, y = log2Reads, fill = Condition, colour = Condition)) +
  geom_boxplot() +
  scale_fill_manual(values = colpal$Condition) +
  scale_colour_manual(values = colpal$Condition) + 
  labs(title = "KIRC: Raw Expression Data (eDat) ", y = "log2Reads") +
  theme_minimal() 

b2 <- eNorm_c1_long %>% 
  ggplot(aes(x = Condition, y = log2Reads, fill = Condition, colour = Condition)) +
  geom_boxplot() +
  scale_fill_manual(values = colpal$Condition) +
  scale_colour_manual(values = colpal$Condition) +
  labs(title = "KIRC: C1 Normalized Expression Data", y = "log2Reads") +
  theme_minimal()

b3 <- eNorm_c2_long %>% 
  ggplot(aes(x = Condition, y = log2Reads, fill = Condition, colour = Condition)) +
  geom_boxplot() +
  scale_fill_manual(values = colpal$Condition) +
  scale_colour_manual(values = colpal$Condition) +
  labs(title = "KIRC: C2 Normalized Expression Data", y = "log2Reads") +
  theme_minimal()

ggarrange(b1, d1, b2, d2, b3, d3, nrow = 3, ncol = 2)

```

Overwrite the previously saved eFil and eNorm objects 

```{r save, eval=FALSE}
# write_rds(eFil, here::here("data", "eFil.rds"))
 # write_rds(eNorm_c1, here::here("data", "KIRC_eNorm_c1.rds"))
 # write_rds(eNorm_c2, here::here("data", "KIRC_eNorm_c2.rds"))
```


> We will only be using cluster 1 samples for all of our downstream analyses, and only using the cluster 2 samples at the end as a validation cohort.  

***

### 4.0 PCA  

Principal Component Analysis (PCA) is a type of dimensionality reduction method. Dimensionality reduction techniques allow us to observe ‘big data’ in a meaningful way, where all of the expression data per sample per gene is converted into units showing the ‘distance’ i.e., similarity between them. Here we’ll be using PCA (tSNE and UMAP are two other methods), which reduces and converts our data points into distinct Principal Components (which have no units of measure) and shows us how much variability exists between our data, and which variables are contributing towards that variation

#### 4.1 Calculating PCA


```{r pca-c1}
# first convert eNorm to log2 + 1

eNorm_c1 <- eNorm_c1 %>% 
  column_to_rownames("miRNA")

eLog <- log2(eNorm_c1 + 1)

# the function we use performs its operation row-wise, and since we want to check the variability between genes and not the samples, we'll transpose our exp df to convert the samples to be rows, and the columns to be our genes. Don't open this df as it might cause R to crash (as there will be more columns than rows in this df now)
t_eLog <- as.data.frame(t(eLog))

# the function to compute PCA. We set scale to FALSE, because we already log10 scaled our data, and center to TRUE, so that the values are converted to Z-scores
pca_c1 <- prcomp(t_eLog, scale = FALSE, center = TRUE) #n has to be less than number of samples

# each score represents the contribution of each gene within each sample
scores_c1 <- pca_c1$x

summary(pca_c1)

```


#### 4.2 Variation Explained by each PC

Here, the summary output shows us the how much variability each PC is contributing in the Proportion of Variance row, and the total sum variability of each preceding PC in the Cumulative Proportion row. The Cumulative Proportion will always add up to a 100% at the last PC.   

Number of PCs = Number of samples  

```{r pca-metrics}

# joining our PCA score to mDat
scores_c1 <- scores_c1 %>% 
  as.data.frame() %>% 
  rownames_to_column("Sample")

mDat_c1 <- mDat %>% 
  right_join(scores_c1, by = "Sample")



# getting the data from the summary function we saw above  
summary_c1 <- data.frame(PC = 1:289, 
                         variation_explained = (pca_c1$sdev)^2 / sum((pca_c1$sdev)^2), 
                         cumulative = cumsum(pca_c1$sdev^2 / sum(pca_c1$sdev^2)))

summary_c1 <- summary_c1 %>% 
  mutate(variation_perc = variation_explained * 100,
         cumulative_perc = cumulative * 100,
         PC = sort(as.factor(PC)))

head(summary_c1)



# visualising the variation contributed by each PC

summary_c1 %>%
  ggplot(aes(x = PC, y = variation_perc)) +
  geom_bar(stat = "identity", fill = "forest green") +
  coord_cartesian(y = c(0,100)) +
  scale_y_continuous(breaks = seq(0,100,10), expand = c(0, 0)) +
  theme_minimal() +
  labs(title = "Variance Explained by each PC", subtitle = "Normalized Expression of 2519 miRNAs", 
       x = "Principal Components", y = "Variance Explained")

# only the first 50 PCs
summary_c1 %>%
  dplyr::slice(1:50) %>%
  ggplot(aes(x = PC, y = variation_perc)) +
  geom_bar(stat = "identity", fill = "forest green") +
  coord_cartesian(y = c(0,100)) +
  scale_y_continuous(breaks = seq(0,100,10), expand = c(0, 0)) +
  theme_minimal() +
  labs(title = "Variance Explained by each PC", subtitle = "Normalized Expression of 2519 miRNAs", 
       x = "Principal Components", y = "Variance Explained")


summary_c1 %>%
  dplyr::slice(1:50) %>% 
  ggplot(aes(x = PC, y = cumulative_perc)) +
  geom_bar(stat = "identity", fill = "forest green") +
  coord_cartesian(y = c(0,100)) +
  scale_y_continuous(breaks = seq(0,100,10), expand = c(0, 0)) +
  theme_minimal() +
  labs(title = "Variance Explained by each PC", subtitle = "Normalized Expression of 2519 miRNAs", 
       x = "Principal Components", y = "Variance Explained")


```

We see from the summary and the plots, that PC1 is contributing about 10% of the variance, PC2 5%, and so on, to add up to 100% at PC289  


#### 4.3 Variables contributing to the variation for each PC

##### 4.3.1 Variation esitmate by P-value

We’ll now check which of our variables actually contribute towards the PCs and drive variance within each PC 

```{r variable-pca-correlation}

library(kableExtra)
library(plomics)

# Selecting the variables of interest
pDat_cor <- mDat_c1 %>% 
  dplyr::select(Sample, Condition, Sex, Self_reported_race, Total_Mapped_on_Precursor_or_miRNA) %>% 
  column_to_rownames("Sample")


scores_c1 <- scores_c1 %>% 
  column_to_rownames("Sample")

# calculating the pvalue significance of the above variables by PC
pca_c1_pval <- plomics::lmmatrix(dep = scores_c1, ind = pDat_cor, metric = "Pvalue") # correlation matrix

# transposing
pca_c1_pval <- t(pca_c1_pval) # only for visual purposes - Not being used for any calculations



# displaying the results for the first 15 in a table highlighting the variables significantly contributing towards each PC
pca_c1_pval %>% 
  as.data.frame() %>% 
  dplyr::slice(1:20) %>% 
  mutate(across(everything(), round, 3)) %>% 
  mutate(across(everything(), ~cell_spec(.x, color = ifelse(.x <= 0.05, "green", "")))) %>% 
  kable(escape = F) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", full_width = F, fixed_thead = T))

```


Looks like all 3 of our variables contribute very significantly towards expression - we'll now display the results as a plot rather than a table


```{r pval-plot}

pca_c1_plot <- pca_c1_pval %>% 
  as.data.frame %>% 
  dplyr::slice(1:20) %>% 
  mutate(Principal_Component = rownames(pca_c1_pval)[1:20],
         PC = as.factor(1:20)) %>% 
  pivot_longer(cols = -c(Principal_Component, PC), names_to = "Variable", values_to = "pval") %>%
  mutate(pval_cat = factor(case_when(
    pval > 0.05  ~ "> 0.05",
    pval < 0.05 & pval > 0.01 ~ "< 0.05",
    pval < 0.01 & pval > 0.001 ~ "< 0.01",
    pval < 0.001 ~ "< 0.001"), 
    levels = c("> 0.05", "< 0.05", "< 0.01", "< 0.001")))


# making a colour palette for the above plot
pc_colpal <- c("white", "#c7dfba", "#8ebe78", "#509e36")
# setting the levels of the pval_cat factor column to the colours in pc_colpal
names(pc_colpal) <- levels(pca_c1_plot$pval_cat)


pca_c1_plot %>% 
  ggplot(aes(x = PC, y = Variable , fill = pval_cat)) +
  geom_tile(col = "lightgray") +
  theme_bw() +
  scale_x_discrete(expand = c(0, 0)) + #expand function fits the plot to its assigned dimesions 
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = pc_colpal)  + 
  coord_fixed() + # very important otherwise height of each tile is elongated!
  labs(title = "Contribution of Variables to Observed Expression\n", x = "", y = "", fill = "P value")

```

##### 4.3.2 Variation esitmate by R-Squared

For the above, we've used p-value as a metric. We'll now calculate the R-squared value for each variable  

**Can you explain what an R-squared value is?**  
-> proportion of variation in the dependent variable that is predictable from the independent variable aka coefficient of variation
- the higher the value, (ex. greater than 0.7) the greater the correlation 

```{r rsq-plot}

pca_c1_rsq <- lmmatrix(dep = scores_c1, ind = pDat_cor, metric = "Rsquared") # correlation matrix

pca_c1_rsq <- t(pca_c1_rsq)

rsq_c1_plot <- pca_c1_rsq %>% 
  as.data.frame %>% 
  dplyr::slice(1:20) %>% 
  mutate(Principal_Component = rownames(pca_c1_rsq)[1:20],
         PC = as.factor(1:20)) %>% 
  pivot_longer(cols = -c(Principal_Component, PC), names_to = "Variable", values_to = "rsq")

rsq_c1_plot %>% 
  ggplot(aes(x = PC, y = Variable , fill = rsq)) +
  geom_tile(col = "lightgray") +
  theme_bw() +
  scale_x_discrete(expand = c(0, 0)) + #expand function fits the plot to its assigned dimensions 
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_gradient(low = "white", high = "#509e36") +
  coord_fixed() + # very important otherwise height of each tile is elongated!
  labs(x = "", y = "", fill = "Rsq")

```

#### 4.4 PCA Plots

Viewing the pval and rsq plots together:


```{r pca-plots, fig.height=5}

p1 <- pca_c1_plot %>% 
  ggplot(aes(x = PC, y = Variable , fill = pval_cat)) +
  geom_tile(col = "lightgray") +
  theme_bw() +
  scale_x_discrete(expand = c(0, 0)) + #expand function fits the plot to its assigned dimesions 
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = pc_colpal)  + 
  coord_fixed() + # very important otherwise height of each tile is elongated!
  labs(title = "Contribution of Variables to Observed Expression\n", x = "", y = "", fill = "P value")

r1 <- rsq_c1_plot %>% 
  ggplot(aes(x = PC, y = Variable , fill = rsq)) +
  geom_tile(col = "lightgray") +
  theme_bw() +
  scale_x_discrete(expand = c(0, 0)) + #expand function fits the plot to its assigned dimesions 
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_gradient(low = "white", high = "#509e36") +
  coord_fixed() + # very important otherwise height of each tile is elongated!
  labs(x = "", y = "", fill = "Rsq")

egg::ggarrange(p1, r1, nrow = 2, ncol = 1, heights = c(3,3)) 

```


**Make plots showing the separation of samples by the computed PC per sample**  

Using mDat:  

1. Make a new column bucketing the `Total_Mapped_on_Precursor_or_miRNA` variable into separate categories (turning this continuous variable into a categorical one), and then show how many samples fall into each of the categories. The number of categories you split the samples into is your choice    
2. Make separate scatter plots for PC1 vs PC2 and PC2 vs PC3 for all the above 4 variables  
3. Set the x- and y-axis limits as the same number (from negative x to positive x)  
4. Colour by variable  
5. Set the `fig.height` and `fig.width` as the same value, so that the plot is a square shape  
 
*Hint: Use `coord_cartesian` to set the axes limits*  

```{r pca-plots-vars, fig.height=20, fig.width=10}

 #convert continuous variable into categorical variable 

range(mDat$Total_Mapped_on_Precursor_or_miRNA)
# 54.11895 92.98247
breaks <- c(50,55,60,65,70,75,80,85,90,95,100)

mDat_categorical <- mDat_c1

mDat_categorical$category <- cut(mDat_categorical$Total_Mapped_on_Precursor_or_miRNA, breaks, labels = c("50-55", "55-60", "60-65", "65-70", "70-75", "75-80", "80-85", "85-90", "90-95", "95-100"))

ggplot(mDat_categorical, aes(x=category)) +
  geom_bar() +
  coord_cartesian(ylim=c(0,250))

# Im unsure what to graph here - ask 

#4 variables = sex, self reported race, condition, total mapped on precursor or mirna 

#PC1 vs PC2

#sex
g1 <- mDat_c1 %>% 
  ggplot(aes(x = PC1, y = PC2, colour = Sex)) +
  geom_point() +
  scale_colour_manual(values = colpal$Sex) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")


#self-reported race
g2 <- mDat_c1 %>% 
  ggplot(aes(x = PC1, y = PC2, colour = Self_reported_race)) +
  geom_point() +
  scale_colour_manual(values = colpal$Self_reported_race) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

#condition
g3 <- mDat_c1 %>% 
  ggplot(aes(x = PC1, y = PC2, colour = Condition)) +
  geom_point() +
  scale_colour_manual(values = colpal$Condition) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

#total mapped on precursor or mirna
g4 <- mDat_categorical %>% 
  ggplot(aes(x = PC1, y = PC2, colour = category)) +
  geom_point() +
  scale_colour_manual(values = colpal$category) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

#ggarrange(g1, g2, g3, g4, nrow = 2, ncol = 2)

#PC2 vs PC3

#sex
g5 <- mDat_c1 %>% 
  ggplot(aes(x = PC2, y = PC3, colour = Sex)) +
  geom_point() +
  scale_colour_manual(values = colpal$Sex) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

#self-reported race
g6 <- mDat_c1 %>% 
  ggplot(aes(x = PC2, y = PC3, colour = Self_reported_race)) +
  geom_point() +
  scale_colour_manual(values = colpal$Self_reported_race) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

#condition
g7 <- mDat_c1 %>% 
  ggplot(aes(x = PC2, y = PC3, colour = Condition)) +
  geom_point() +
  scale_colour_manual(values = colpal$Condition) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
  theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

#total mapped on precursor or mirna
g8 <- mDat_categorical %>% 
  ggplot(aes(x = PC2, y = PC3, colour = category)) +
  geom_point() +
  scale_colour_manual(values = colpal$category) +
  coord_cartesian(x = c(-50, 50), y = c(-50, 50)) +
  my_theme +
   theme(legend.position = "bottom") +
  labs(title = "Filtered + Normalized")

ggarrange(g1, g5, g2, g6, g3, g7, g4, g8, nrow = 4, ncol = 2)

```

***

### 5.0 Differential Expression  

#### 5.1 Unstratified 

We're going to use the Wilcoxon Rank Sum test to test for expression differences between our samples  

**Can you write down what this test measures?**  
- non parametric 
  - data does not have to follow a distribution pattern 
  
- determines if two independent groups of observations come from populations with the same distribution patterns 
- measure of difference in the ranks (not actual values) between two groups of samples 

- the two groups have approximately equal ranks, the distribution is the same - test does not reject the null hypothesis 

```{r comparison-dfs, error=FALSE, warning=FALSE, message=FALSE, cache = TRUE}

# making separate eDat and pDats for our combinations
NM_Tumour_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "Fetal")
NM_Tumour_eDat <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% NM_Tumour_pDat$Sample))

NM_Fetal_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "Tumour")
NM_Fetal_eDat <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% NM_Fetal_pDat$Sample))

Tumour_Fetal_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "NM")
Tumour_Fetal_eDat <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% Tumour_Fetal_pDat$Sample))

Condition <- pDat_c1_fetal %>% 
  dplyr::select(Sample, Condition)
Condition$Condition <- as.factor(Condition$Condition)

```

Now, we want to apply the test per miRNA - and that means running the test 2519 times, which is not something we should be doing manually. And in such cases where we want to be applying the same steps over and over again, we can use a [for-loop](https://intro2r.com/loops.html) which will reiterate the same steps over different inputs  

I'll show how the test works for one miRNA  

```{r wilcox-test, error=FALSE, warning=FALSE, message=FALSE, cache = TRUE}

# package
library(coin)

# showing how the test works for one miRNA

test_mirna <- Tumour_Fetal_eDat %>% 
  
  # selecting the first miRNA
  dplyr::slice(1) %>% 
  
  # the wilcox test in R requires to transpose the df so that ou samples are rows, and miRNAs are columns
  t() %>% 
  
  # when we transpose a df, it turns into a matrix
  as.data.frame() %>% 
  rownames_to_column("Sample") %>% 
  left_join(Condition, by = "Sample")

# running the test
test_wilcox <- wilcox_test(test_mirna$`hsa-let-7a-2-3p` ~ test_mirna$Condition)

# pvalue for this miRNA between tumour and NM
test_pvalue <- pvalue(test_wilcox)
test_pvalue

# [1] 0.7161871


```

**What is multiple-testing correction, and why is it important?**  


Now, when writing the for loop, we have to ensure that all of our inputs have the same value, cause we can't be writing the name of each miRNA (as above for hsa-let-7a-2-3p) within the function. 

```{r wilcox, error=FALSE, warning=FALSE, message=FALSE, cache = TRUE}

#NM-Tumour

# making an empty value which has the same number of rows as our miRNAs. 
#We will be storing all of our test output results within this value
pvals_NM_Tumour <- rep(NA, nrow(eNorm_c1)) 

# Here, I'm saying that for each row of NM_Tumour_eDat SEPARATELY
for(i in 1:nrow(NM_Tumour_eDat)){ 
  
  # assign x as an miRNA. the i signifies that the value will change each time, 
  # starting with row 1 all the way to the last row/miRNA
  x <- as.data.frame(t(NM_Tumour_eDat[i,]))
  
# as the name for each miRNA is different, we will just name that column miRNA
  colnames(x)[1] <- "miRNA"
  
  # join our sample conditions as we did above for this miRNA
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  
  # assign a1 as the output of the test as above
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  
  # assign the p-value of this miRNA to it's corresponding row i (i.e., 1, 2, 3...) within the empty value
  # So if the miRNA we're testing is the 5th miRNA in the eDat, the pvalue of this miRNA will be assigned to row 5
  pvals_NM_Tumour[i] <- pvalue(a1) 
  
}

pvals_NM_Tumour <- as.data.frame(pvals_NM_Tumour)

# multiple testing correction
pvals_NM_Tumour$pvals_NM_Tumour_adj <- p.adjust(pvals_NM_Tumour$pvals_NM_Tumour, method = "fdr")



# NM-Fetal
pvals_NM_Fetal <- rep(NA, nrow(eNorm_c1)) 
for(i in 1:nrow(NM_Fetal_eDat)){ 
  x <- as.data.frame(t(NM_Fetal_eDat[i,]))
  colnames(x)[1] <- "miRNA"
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  pvals_NM_Fetal[i] <- pvalue(a1) 
}
pvals_NM_Fetal <- as.data.frame(pvals_NM_Fetal)
pvals_NM_Fetal$pvals_NM_Fetal_adj <- p.adjust(pvals_NM_Fetal$pvals_NM_Fetal, method = "fdr")

# Tumour-Fetal
pvals_Tumour_Fetal <- rep(NA, nrow(eNorm_c1)) 
for(i in 1:nrow(Tumour_Fetal_eDat)){ 
  x <- as.data.frame(t(Tumour_Fetal_eDat[i,]))
  colnames(x)[1] <- "miRNA"
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  pvals_Tumour_Fetal[i] <- pvalue(a1) 
}
pvals_Tumour_Fetal <- as.data.frame(pvals_Tumour_Fetal)
pvals_Tumour_Fetal$pvals_Tumour_Fetal_adj <- p.adjust(pvals_Tumour_Fetal$pvals_Tumour_Fetal, method = "fdr")


```


```{r join-pval-wilcox, error=FALSE, warning=FALSE, message=FALSE, cache = TRUE}


# joining all 3
pval_mirs <- as.data.frame(rownames(eNorm_c1))
colnames(pval_mirs)[1] <- "miRNA"

pval_mirs <- cbind(pval_mirs, pvals_NM_Tumour, pvals_NM_Fetal, pvals_Tumour_Fetal)
pval_mirs <- pval_mirs %>% 
  column_to_rownames("miRNA")

pval_mirs <- round(pval_mirs, digits = 2)

pval_mirs <- pval_mirs %>% 
  rownames_to_column("miRNA")

head(pval_mirs)

```

**Save `pval_mirs` as an Excel file**  

```{r, eval=FALSE}

 write.xlsx(pval_mirs, here::here ("data", "pval_mirs.xlsx"))

```



**Now, select the miRNAs which are significant at a pvalue <= 0.05 in NM-Tumour and NM-Fetal, but not significant in Tumour-Fetal**  

```{r oncofetal-mirs, cache = TRUE}

oncofetal_mirs <- pval_mirs %>% 
  filter(pvals_NM_Tumour_adj <= 0.05 & pvals_NM_Fetal_adj <= 0.05 & pvals_Tumour_Fetal_adj >= 0.05)

# oncofetal_mirs <- pval_mirs %>% 
#   filter(pval_mirs, pvals_NM_Tumour >= 0.05 & pvals_NM_Fetal >= 0.05 & pvals_Tumour_Fetal < 0.05)

#oncofetal_mirs <- filter(pval_mirs, pvals_NM_Tumour >= 0.05 & pvals_NM_Fetal >= 0.05 & pvals_Tumour_Fetal < 0.05)
# this is wrong, produces 39 

nrow(oncofetal_mirs)

head(oncofetal_mirs)
#produces 81

```


 > CHECKPOINT: You should have 0 oncofetal renal miRNAs 
 

#### 5.2 Sex-Stratified 
 
 **Repeat the above, but this time dividing up the male and female samples from cluster 1, and running the test individually**  
 

```{r sex}

pDat_c1_fetal$Sex[pDat_c1_fetal$Sex == "M"]<-"Male"
pDat_c1_fetal$Sex[pDat_c1_fetal$Sex == "F"]<-"Female"
pDat_c2_fetal$Sex[pDat_c2_fetal$Sex == "M"]<-"Male"
pDat_c2_fetal$Sex[pDat_c2_fetal$Sex == "F"]<-"Female"

males <- pDat_c1_fetal %>% 
  filter(Sex == "Male")

#males_eDat <- all_cols[colnames(eNorm_c1) %in% males$Sample]

males_eDat <- eNorm_c1 %>% 
    dplyr::select(which(names(eNorm) %in% males$Sample))

  
females <- pDat_c1_fetal %>% 
    filter(Sex == "Female")


#females_eDat <- all_cols[colnames(eNorm_c1) %in% females$Sample]
females_eDat <- eNorm_c1 %>% 
    dplyr::select(which(names(eNorm) %in% females$Sample))


#checkpoint values are wrong 

#195 males, 94 females
# maybe it's because we included fetal? but there are 6 male fetal 
# 6 male fetal, 4 female fetal 


```

 > CHECKPOINT: You should have 195 male samples, and 94 female samples within cluster 1  

```{r males, message=FALSE, error=FALSE, warning=FALSE, echo=FALSE}

NM_Tumour_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "Fetal") 
  
NM_Tumour_pDat_males <- NM_Tumour_pDat %>% 
  filter(Sex == "Male")
# now we get 189 males 
# this excludes fetal samples 
  
NM_Tumour_eDat_males <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% NM_Tumour_pDat_males$Sample))

#-------------------------------------------------------------------

NM_Fetal_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "Tumour")

NM_Fetal_pDat_males <- NM_Fetal_pDat %>% 
  filter(Sex == "Male")
#36
  
NM_Fetal_eDat_males <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% NM_Fetal_pDat_males$Sample))

#-------------------------------------------------------------------

Tumour_Fetal_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "NM")

Tumour_Fetal_pDat_males <- Tumour_Fetal_pDat %>% 
  filter(Sex == "Male")
  
Tumour_Fetal_eDat_males <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% Tumour_Fetal_pDat_males$Sample))
#165

#-------------------------------------------------------------------
pDat_c1_fetal_males <- pDat_c1_fetal %>% 
  filter(Sex == "Male")

Condition_males <- pDat_c1_fetal_males %>% 
  dplyr::select(Sample, Condition)
Condition_males$Condition <- as.factor(Condition_males$Condition)

#-------------------------------------------------------------------
# WILCOXIN MANN-WHITNEY-U TEST FOR MALES
#NM-Tumour

# making an empty value which has the same number of rows as our miRNAs. 
#We will be storing all of our test output results within this value
pvals_NM_Tumour_males <- rep(NA, nrow(eNorm_c1)) 

# Here, I'm saying that for each row of NM_Tumour_eDat SEPARATELY
for(i in 1:nrow(NM_Tumour_eDat_males)){ 
  
  # assign x as an miRNA. the i signifies that the value will change each time, 
  # starting with row 1 all the way to the last row/miRNA
  x <- as.data.frame(t(NM_Tumour_eDat_males[i,]))
  
# as the name for each miRNA is different, we will just name that column miRNA
  colnames(x)[1] <- "miRNA"
  
  # join our sample conditions as we did above for this miRNA
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  
  # assign a1 as the output of the test as above
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  
  # assign the p-value of this miRNA to it's corresponding row i (i.e., 1, 2, 3...) within the empty value
  # So if the miRNA we're testing is the 5th miRNA in the eDat, the pvalue of this miRNA will be assigned to row 5
  pvals_NM_Tumour_males[i] <- pvalue(a1) 
  
}

pvals_NM_Tumour_males <- as.data.frame(pvals_NM_Tumour_males)

# multiple testing correction
pvals_NM_Tumour_males$pvals_NM_Tumour_adj <- p.adjust(pvals_NM_Tumour_males$pvals_NM_Tumour, method = "fdr")



# NM-Fetal
pvals_NM_Fetal_males <- rep(NA, nrow(eNorm_c1)) 
for(i in 1:nrow(NM_Fetal_eDat_males)){ 
  x <- as.data.frame(t(NM_Fetal_eDat_males[i,]))
  colnames(x)[1] <- "miRNA"
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  pvals_NM_Fetal_males[i] <- pvalue(a1) 
}
pvals_NM_Fetal_males <- as.data.frame(pvals_NM_Fetal_males)
pvals_NM_Fetal_males$pvals_NM_Fetal_adj <- p.adjust(pvals_NM_Fetal_males$pvals_NM_Fetal, method = "fdr")

# Tumour-Fetal
pvals_Tumour_Fetal_males <- rep(NA, nrow(eNorm_c1)) 
for(i in 1:nrow(Tumour_Fetal_eDat_males)){ 
  x <- as.data.frame(t(Tumour_Fetal_eDat_males[i,]))
  colnames(x)[1] <- "miRNA"
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  pvals_Tumour_Fetal_males[i] <- pvalue(a1) 
}
pvals_Tumour_Fetal_males <- as.data.frame(pvals_Tumour_Fetal_males)
pvals_Tumour_Fetal_males$pvals_Tumour_Fetal_adj <- p.adjust(pvals_Tumour_Fetal_males$pvals_Tumour_Fetal, method = "fdr")


```


```{r join-pval-wilcox-p2, error=FALSE, warning=FALSE, message=FALSE, cache = TRUE}


# joining all 3
pval_mirs_males <- as.data.frame(rownames(eNorm_c1))
colnames(pval_mirs_males)[1] <- "miRNA"

pval_mirs_males <- cbind(pval_mirs_males, pvals_NM_Tumour_males, pvals_NM_Fetal_males, pvals_Tumour_Fetal_males)
pval_mirs_males <- pval_mirs_males %>% 
  column_to_rownames("miRNA")

pval_mirs_males <- round(pval_mirs_males, digits = 2)

pval_mirs_males_round <- pval_mirs_males %>% 
  rownames_to_column("miRNA")

head(pval_mirs_males_round)

#oncofetal mirs male

oncofetal_mirs_male <- pval_mirs_males_round %>% 
  filter(pvals_NM_Tumour_adj <= 0.05 & pvals_NM_Fetal_adj <= 0.05 & pvals_Tumour_Fetal_adj >= 0.05)

nrow(oncofetal_mirs_male)

head(oncofetal_mirs_male)
#84


```

> CHECKPOINT: You should have 84 male-specific oncofetal renal miRNAs 


```{r females, message=FALSE, error=FALSE, warning=FALSE, echo=FALSE}
NM_Tumour_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "Fetal") 
  
NM_Tumour_pDat_females <- NM_Tumour_pDat %>% 
  filter(Sex == "Female")
# now we get 90 females 
# this excludes fetal samples 
  
NM_Tumour_eDat_females <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% NM_Tumour_pDat_females$Sample))

#-------------------------------------------------------------------

NM_Fetal_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "Tumour")

NM_Fetal_pDat_females <- NM_Fetal_pDat %>% 
  filter(Sex == "Female")
#10
  
NM_Fetal_eDat_females <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% NM_Fetal_pDat_females$Sample))

#-------------------------------------------------------------------

Tumour_Fetal_pDat <- pDat_c1_fetal %>% 
  filter(Condition != "NM")

Tumour_Fetal_pDat_females <- Tumour_Fetal_pDat %>% 
  filter(Sex == "Female")
  
Tumour_Fetal_eDat_females <- eNorm_c1 %>% 
  dplyr::select(which(names(eNorm_c1) %in% Tumour_Fetal_pDat_females$Sample))
#88

#-------------------------------------------------------------------
pDat_c1_fetal_females <- pDat_c1_fetal %>% 
  filter(Sex == "Female")

Condition_females <- pDat_c1_fetal_females %>% 
  dplyr::select(Sample, Condition)

Condition_females$Condition <- as.factor(Condition_females$Condition)

#-------------------------------------------------------------------
# WILCOXIN MANN-WHITNEY-U TEST FOR FEMALES
#NM-Tumour

pvals_NM_Tumour_females <- rep(NA, nrow(eNorm_c1)) 

for(i in 1:nrow(NM_Tumour_eDat_females)){ 
  
 
  x <- as.data.frame(t(NM_Tumour_eDat_females[i,]))
  
  colnames(x)[1] <- "miRNA"
  
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  
  pvals_NM_Tumour_females[i] <- pvalue(a1) 
  
}

pvals_NM_Tumour_females <- as.data.frame(pvals_NM_Tumour_females)

# multiple testing correction
pvals_NM_Tumour_females$pvals_NM_Tumour_adj <- p.adjust(pvals_NM_Tumour_females$pvals_NM_Tumour, method = "fdr")



# NM-Fetal
pvals_NM_Fetal_females <- rep(NA, nrow(eNorm_c1)) 
for(i in 1:nrow(NM_Fetal_eDat_females)){ 
  x <- as.data.frame(t(NM_Fetal_eDat_females[i,]))
  colnames(x)[1] <- "miRNA"
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  pvals_NM_Fetal_females[i] <- pvalue(a1) 
}
pvals_NM_Fetal_females <- as.data.frame(pvals_NM_Fetal_females)
pvals_NM_Fetal_females$pvals_NM_Fetal_adj <- p.adjust(pvals_NM_Fetal_females$pvals_NM_Fetal, method = "fdr")

# Tumour-Fetal
pvals_Tumour_Fetal_females <- rep(NA, nrow(eNorm_c1)) 
for(i in 1:nrow(Tumour_Fetal_eDat_females)){ 
  x <- as.data.frame(t(Tumour_Fetal_eDat_females[i,]))
  colnames(x)[1] <- "miRNA"
  x <- x %>% 
    rownames_to_column("Sample") %>% 
    left_join(Condition, by = "Sample")
  a1 <- wilcox_test(x$miRNA ~ x$Condition)
  pvals_Tumour_Fetal_females[i] <- pvalue(a1) 
}
pvals_Tumour_Fetal_females <- as.data.frame(pvals_Tumour_Fetal_females)

pvals_Tumour_Fetal_females$pvals_Tumour_Fetal_adj <- p.adjust(pvals_Tumour_Fetal_females$pvals_Tumour_Fetal, method = "fdr")

# joining all 3
pval_mirs_females <- as.data.frame(rownames(eNorm_c1))
colnames(pval_mirs_females)[1] <- "miRNA"

pval_mirs_females <- cbind(pval_mirs_females, pvals_NM_Tumour_females, pvals_NM_Fetal_females, pvals_Tumour_Fetal_females)
pval_mirs_females <- pval_mirs_females %>% 
  column_to_rownames("miRNA")

pval_mirs_females <- round(pval_mirs_females, digits = 2)

pval_mirs_females_round <- pval_mirs_females %>% 
  rownames_to_column("miRNA")

head(pval_mirs_females_round)

#oncofetal mirs female

oncofetal_mirs_female <- pval_mirs_females_round %>% 
  filter(pvals_NM_Tumour_adj <= 0.05 & pvals_NM_Fetal_adj <= 0.05 & pvals_Tumour_Fetal_adj >= 0.05)

nrow(oncofetal_mirs_female)

head(oncofetal_mirs_female)
#22

```
```{r unique count}

#we have 84 male specific oncofetal miRNAs and 22 female specific oncofetal miRNAs 

m_f_shared_oncofetal <- sum(oncofetal_mirs_female$miRNA %in% oncofetal_mirs_male$miRNA)

#value = 16

unique_female_oncofetal <- oncofetal_mirs_female %>% 
  select(miRNA) %>% 
  distinct() %>% 
  anti_join(oncofetal_mirs_male, by = "miRNA") %>% 
  nrow()

cat("Number of unique renal oncofetal miRNAs in females =", unique_female_oncofetal)
#6

unique_male_oncofetal <- oncofetal_mirs_male %>% 
  select(miRNA) %>% 
  distinct() %>% 
  anti_join(oncofetal_mirs_female, by = "miRNA") %>% 
  nrow()

cat("Number of unique renal oncofetal miRNAs in males =", unique_male_oncofetal)
#68
```



> CHECKPOINT: You should have 22 female-specific oncofetal renal miRNAs 
- check how many oncofetal mirs are common/shared between males and females
  - should have 16
- which ones are male unique and which ones are female unique?
  - unique female : 6
  - unique male : 68

**Save the male-specific oncofetal miRNAs**

```{r, eval=FALSE}
# write.xlsx(oncofetal_mirs_male, here::here ("data", "oncofetal_mirs_male.xlsx"))
# write.xlsx(oncofetal_mirs_female, here::here ("data", "oncofetal_mirs_female.xlsx"))


```

***

End of Script  

***






