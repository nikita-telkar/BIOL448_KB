---
title: "KIRC: Quality Control" 
author: "Nikita Telkar"
date: "February 2023"
output: 
  html_document: 
    keep_md: yes 
    toc: true  
    toc_depth: 4
    toc_float: 
      collapsed: false 
      smooth_scroll: true
    theme: flatly  
    highlight: haddock
---

***

### 0.0 Introduction  

Here, we’re going to perform quality control measures on our data  
  
What is QC and why is it important?  
  
Before we start analysing our data, to get meaningful interpretations of our results, we have to ensure that the data that we’re using is actually representative of our sample expression. We don’t want samples or sequences (here, miRNAs) to represent a biased representation. For example, a large handful of sequences record 0 counts, and keeping these sequences in our data would lead us to believe that the average expression of our whole dataset is close to zero (when that is not the case)  

And hence, the basic steps of QC include:

- Filtering: removing sequences/samples of low quality  
- Normalization: Re-adjusting and standardising expression of filtered sequences for each gene between samples, and further all genes within the same sample  


### 1.0 Loading Packages and Data  

Loading all of our packages:  

```{r packages, error=FALSE, message=FALSE, warning=FALSE, results='hide'}

# rmarkdown packages
library(knitr) 
library(rmarkdown)

# data wrangling packages
library(tidyverse)
library(janitor)

# data loading packages
library(readxl) 
library(openxlsx)
library(here)


# setting global script options - i.e, parameters/arguents that will be applied to all chunks, without having to explicity specify them each time
knitr::opts_chunk$set(warning = FALSE, message = FALSE, error = FALSE)

```

Reading in data:  

```{r data}
 pDat <- read_excel(here::here("data", "KIRC_pDat_replicates_removed.xlsx"))
 eDat <- read_rds(here::here("data", "KIRC_eDat_replicates_removed.RDS"))
 mDat <- read_rds(here::here("data", "KIRC_mDat.RDS"))
 
 #  summary(mDat)

```

**Add your choice of font available at [Google Fonts](https://fonts.google.com/), and make your own customized ggplot2 theme**. We will now use this theme option for all future plots  

```{r theme-and-colpal}

library(showtext)
library(extrafont)
knitr::opts_chunk$set(fig.showtext = TRUE, fig_retina = 1) # needed to render show_text


font_add_google("Open Sans", "Sans")

# colpal <- list(Condition = c(`Fetal` = "#ECB576", `NM` = "#115363", `Tumour` = "#A34237"),
#                Sex = c(`Male` = "#E05D5D", `Female` = "#ffb708"),
#                Self_reported_race = c(`Black or African American` = "#9BBC49", 
#                                       `Asian` = "#5B8D33", 
#                                       `White` = "#286E16", 
#                                       `Not Reported` = "#666666"))

colpal <- list(Condition = c(`Fetal` = "#4D6DA0", `NM` = "#72B592", `Tumour` = "#C5E3AA"),
               Sex = c(`Male` = "#9dba8f", `Female` = "#edcba0"),
               Self_Reported_Race = c(`African American or Black` = "#698ECF", `American Indian or Alaska Native` = "#565199", `Asian` = "#E26E51", `Caucasian or White` = "#F6D076", `Not Reported/Unknown` = "#de425b"))


my_theme <- theme_minimal() +
  theme(plot.title = element_text(family = "Sans", size = 14),
        plot.subtitle = element_text(family = "Sans", size = 12),
        legend.text = element_text(family = "Sans", size = 10),
        axis.title = element_text(family = "Sans", size = 14),
        axis.text = element_text(family = "Sans", size = 12))


# needed to bind ggplot and our custom font
showtext_auto()

```

***

### 2.0 Formatting  

**Make `eDat_long` as in the previous script, which contains the log2(x+1) expression data and phenotypic data all in one dataframe**  

```{r eDat-long}

eDat_long <- eDat %>% 
  pivot_longer(cols = -c(precursor, miRNA), names_to = "Sample", values_to = "Reads")


eDat_long <- eDat_long %>% 
  left_join(pDat, by = "Sample")


eDat_long <- eDat_long %>% 
  mutate(log2Reads = log2(Reads))
  

eDat_long <- eDat_long %>% 
  mutate(log2Reads = log2(Reads + 1))


eDat_long %>% 
  ggplot(aes(x = Condition, y = log2Reads, fill = Condition, colour = Condition)) +
  geom_boxplot() +
  scale_fill_manual(values = colpal$Condition) +
  scale_colour_manual(values = colpal$Condition) +
  theme_minimal() 

```

***

### 3.0 Filtering

We perform filtering to remove any genes/sequences that have very low counts and might not contribute meaningfully towards our data. There's a number of different ways you can filter by, a few being: 

- By Counts: Expression Count of *x* or more in *y* number of samples  
- By Counts and % of Samples: Expression Count of *x* or more in *y*% of samples  
- By Counts and No. of Samples: Expression Count of *x* or more in *y* samples  

We'll go through examples of each:  

#### 3.1 Removing miRNAs with 0 counts  

The first, most basic, filtering step is to remove miRNAs which have 0 counts of expression in *all samples*. From the density plots in the previous script, we saw that the majority of our miRNAs have 0 expression (hence the highest density at Reads 0 on the x-axis)  

```{r fil-any-0}

eDat <- eDat %>% 
  unite("mirs", c(precursor, miRNA), sep = ":") %>% 
  column_to_rownames("mirs")

eFil_0 <- eDat %>% 
   filter(if_any(everything(), ~ .x > 0))

dim(eFil_0)

```

**To check if we have any miRNAs with 0 in all samples mistakenly left, use the `rowSums` function to make a new column and `filter` to select entries which have an entry of 0 within the sum column**  

```{r sum-0}

#eFil_0$zeros <- rowSums(eFil_0==0) == ncol(eFil_0)

#sum(eFil_0$zeros)

  # = 0 -> there are no columns that only have zeros in all samples 
  # there are 2739 obs. of 565 variables - matches desired output at checkpoint
# I commented out this chunk so when eFil_0 is read back in, the T/F column is gone 

```


> **CHECKPOINT:** Your `eFil_0` df should have 2739 rows and 565 columns  

However, that does leave us with some miRNAs that have expression > 0 in some samples, but with expression = 0 in the rest of the samples    

**Using `eDat_long` make a boxplot of the expression of hsa-miR-4797-3p by Condition. Add the argument `geom_jitter(width = 0.2)` at the end**  

```{r plot-miR-4797-3p}

eDat_long %>% 
  ggplot(aes(x = Condition, y = "hsa-miR-4797-3p", fill = Condition, colour = Condition)) +
  geom_boxplot() +
  scale_fill_manual(values = colpal$Condition) +
  scale_colour_manual(values = colpal$Condition) +
  theme_minimal() +
  geom_jitter(width = 0.2)
  
```

Do you think we should filter out miRNAs with 0 expression in all samples, or only miRNAs with 0 expression in some samples? Give a pro and con that you can think for both filtering criteria:  

Filter out miRNAs with 0 expression in *all* samples:  
Pro:  provides a true read of expression data
Con:  Average reads may come out to zero - will be difficult to identify and visualize any changes or upticks in expression 

Filter out miRNAs with 0 expression in *some* samples:  
Pro:  may help us visualize expression pattern changes - the differences & trends will be more obvious 
Con:  It's good to keep them in for comparison across the differing sample types - because what if the miRNA is re-expressed in a tumor sample and could be oncofetal 


#### 3.2 Filtering by % of Samples   

Usually, filtering by % of samples occurs when you have distinct groups, like our tumour and controls, for examples.  

We select to keep miRNAs with a count of *x* in *y*% of samples in each of the groups, and then retain the miRNAs that pass that filtering criteria. Some of the miRNAs that pass would be common between the two groups, and some would be present in only either of the two groups (uniquely expressed for that group)  

While retaining miRNAs with expression in 10% (as an example of %) of tumour samples and NM samples separately would work here given that we have a high number of samples (T = 484, NM = 71), however we only have 10 fetal samples. 10% of 10 samples is just 1 sample - meaning that we would retain miRNAs which had expression in any one sample, which could mean that we keep all miRNAs, and none might be filtered out (effectively rendering our filtering step useless)  

--> The steps to filter out % of samples is the same as the below: filtering by number of samples  


#### 3.3 Filtering by Number of Samples      

As we have 10 fetal samples, this is the filtering criteria we are going to be using -- expression >= 1 in all 10 fetal samples, as opposed to any random 10 samples, because those 10 random samples could be only Tumour or only NM, and ideally in this case, we would want those 10 samples to be mixed within the different conditions  

To keep miRNAs with expression of >=1 in our fetal samples, we'll first have to **separate out the fetal samples**  

```{r fetal}

pDat_fetal <- pDat %>% 
  filter(Condition == "Fetal")

# eDat_fetal <- eDat %>% 
#   filter(Condition == "Fetal")

eDat_fetal <- eDat[, grep("^Rob", names(eDat))]

```

We'll first convert our `eDat_fetal` into a logical df, which will give us a TRUE or FALSE value based on the criteria we assign  

```{r fetal-filtering}

eFil_fetal_logical_df <- eDat_fetal >= 1

head(eFil_fetal_logical_df)

```

We'll now sum the number of TRUE values per row (by default if you use the function rowSums on a logical df, it will count each TRUE value as 1 unit)

```{r fetal-filtering-sum}

eFil_fetal_sum <- eFil_fetal_logical_df %>% 
  as.data.frame() %>% 
  # the above function converts the df into a matrix, and there are a few functions we cannot apply to matrices
  mutate(Sum = rowSums(.)) %>% 
  dplyr::select(Sum, everything()) %>% 
  dplyr::arrange(Sum)

head(eFil_fetal_sum)

```

Now, we want to keep only miRNAs which have an expression of >= 1 in *each* sample, and so we'll **filter the Sum column to keep miRNAs with a sum of 10 or more**    

```{r fetal-filtered}

eFil_fetal_filtered <- eFil_fetal_sum %>% 
  filter(Sum >= 10)
  

```

**Now, join the filtered miRNAs from the logical type eFil_fetal df to eDat to get the actual raw expression for all samples**  

```{r make-efil}

join_cols <- grep("^Rob", names(eFil_fetal_filtered), value = TRUE)

eFil_1_10 <- eFil_fetal_filtered %>% 
  left_join(eDat, by = join_cols)

eFil_1_10 <- left_join(eFil_fetal_filtered, eDat,by= join_cols)
#both produce the same results

# use left join 
  
  # combine eFil_fetal_filtered to eDat (entire)
  

```

The nomenclature eFil_1_10 signifies that the df is a filtered df (eFil), and is filtered by expression of 1 (eFil_1) in 10 samples (eFil_1_10)  

> **CHECKPOINT:** Your filtered df with raw expression counts, `eFil`, should have 975 rows and 566 columns  

#### 3.4 Remove duplicate mature miRNAs     

Each mature miRNA (the ones having -3p and -5p at the end of their names) comes from precursor miRNAs - one precursor (e.g., miR-200) gives rise to two mature miRNAs (miR-200-3p and miR-200-5p). Now, there are a few precursors which give rise to the same two mature miRNAs (usually because it's only a few nucleotide difference somewhere in the hairpin loop of the precursor miRNA sequence).  

Let's first check which mature miRNAs are duplicated  

```{r dup-mirs}
#issues with knitting since obj have not yet been created - will ust comment out for now 
# eFil_1_10 %>% 
#   separate(mirs, c("precursor", "miRNA"), sep = ":") %>% 
#   dplyr::count(miRNA) %>% # count the frequency of mature miRNAs
#   filter(n > 1) # filter to keep only the ones which have a count of more than 1

```

So, we can see that there are 78 mature miRNAs (within our fetal filtered miRNAs df) that have been duplicated - we're only going to keep the ones which have the highest overall expression  


```{r fetal-fil-mature}
# 
# eFil <- eFil_1_10 %>%
#   separate(mirs, c("precursor", "miRNA"), sep = ":") %>%
# 
#   mutate(Sum = rowSums(select_if(., is.numeric))) %>%
#   # here I'm specifying to select only the numeric columns, because our first columns are the miRNA names
# 
#   group_by(miRNA) %>%
#   # grouping by the mature miRNA names
# 
#   slice_max(Sum) %>%
#   # within each mature miRNA group, only keeping the ones which have the highest value in Sum
# 
#   dplyr::select(-Sum, -precursor) %>%
#   # removing the Sum and miRNA precursor column (as we have other dfs we can match to find out the precursor if needed)
# 
#   distinct(miRNA, .keep_all = TRUE) %>%
#   # remove duplicates within the miRNA column
# 
#   column_to_rownames("miRNA")
# 
# dim(eFil)

```

**CHECKPOINT:** Your filtered df with mature miRNAs `eFil` should have 874 rows and 565 columns 

**Make the boxplots and density plots for our filtered data, as we did for the raw data in the previous script, and display them all togther **  
*Hint: Make eFil_long*  

```{r fil-plots}

# eFil_long <- 
#   
# 
# d1 <- 
# 
#   
# d2 <- 
# 
#     
# b1 <- 
# 
# 
# b2 <- 
# 
# 
# library(ggpubr)
# ggarrange(b1, d1, b2, d2, nrow = 2, ncol = 2)

```

***


### 4.0 Separating by Cluster

**Make separate eFils and pDats per KIRC cluster and by fetal** 

```{r clusters}

# 
# 
# # cluster 1 filtered
# pDat_cluster_1 <- pDat %>% 
# 
# 
# eFil_cluster_1 <- eFil %>% 
# 
# 
# 
# # cluster 2 filtered
# pDat_cluster_2 <- pDat %>% 
# 
# 
# eFil_cluster_2 <- eFil %>% 
# 
# 
# 
# # fetal filtered
# eFil_fetal <- eFil %>% 
# 

```

> **CHECKPOINT: You should have 279 samples in Cluster 1, and 276 samples in Cluster 2**  


**We'll now join the fetal samples to both cluster 1 and cluster 2**   

```{r efil-cluster-fetal}

# eFil_c1_fetal <- eFil_fetal %>% 
# 
# 
# pDat_c1_fetal <- pDat %>% 
# 
# 
# 
# eFil_c2_fetal <- eFil_fetal %>% 
# 
# 
# pDat_c2_fetal <- pDat %>% 
# 

```

> **CHECKPOINT: You should have 289 samples in xDat_c1_fetal, and 286 samples in xDat_c2_fetal**  

**Let's check the density and boxplots for our eFil and separated clusters together now**  

```{r efil-cluster-plots, fig.width=10, fig.height=5}

# d3 <- 
# 
#   
# d4 <- 
# 
# 
# b3 <- 
# 
# 
# b4 <- 
#   
#   
# ggarrange(b2, d2, b3, d3, b4, d4, nrow = 3, ncol = 2)

```

***

### 5.0 Normalization

Now that we’ve filtered our data, it’s not in the ‘shape’ it was before - you can also see for that the filtered plots look different from the raw data.  

To take into account that the relative expression (exp between one miRNA to another) between the miRNAs within our eFil dataset is different from that of the relative expression between miRNas in our original, raw eDat df, we use a technique known as normalization

Normalization takes into account the full expression dataset that we have, and adjusts the expression of each miRNA, relative to the whole dataset. It outputs a numerical value for each miRNA which is either subtracted to and or added to the original expression

We’re going to use the [Relative Log Expression](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0206312#:~:text=Relative%20Log%20Expression%20(RLE)%3A,geometric%20mean%20across%20all%20samples.) method of normalization, and now that we've separated our samples into 2 datasets by cluster, we're going to normalize each one separately:  

```{r norm-c1}
# 
# library(DESeq2)
# library(edgeR)
# 
# filtered_mirna_names <- as.data.frame(row.names(eFil)) # only making filtered_mirna_names once as the miRNAs are the same between both clusters
# samples_cluster_1 <- pDat_c1_fetal$Sample
# 
# # computing normalized counts (between sample normalization of miRNA expression)
# norm_counts_c1 <- DGEList(genes = filtered_mirna_names, 
#                           counts = eFil_c1_fetal, 
#                           samples = samples_cluster_1)
# 
# norm_counts_c1 <- calcNormFactors(norm_counts_c1, method = "RLE")
# 
# head(norm_counts_c1[["samples"]]) # the norm.factors is the numerical adjustment value that will be applied to the raw expression
# 
# # performing within sample normalization of miRNA expression (CPM = Counts per Million = RPM = Reads per Million)
# eNorm_c1 <- cpm(norm_counts_c1)
# 
# # converting to our usual log2(x+1) expression
# eNorm_c1 <- log2(eNorm_c1 + 1) 
# 
# # converting the expression counts into whole numbers
# eNorm_c1 <- round(eNorm_c1, digits = 0)
# 
# eNorm_c1 <- as.data.frame(eNorm_c1)

```

**Repeat the above for cluster 2**  

```{r norm-c2}


```

**Make density and boxplots for normalized data, and display all plots (you should have a total of 10 plots) together** 
*Hint: make eNorm_long*  

```{r norm-plots, fig.width=10, fig.height=12}
# 
# eNorm_c1_long <- eNorm_c1 %>% 
#   
# 
# eNorm_c2_long <- eNorm_c2 %>% 
#   
#   
# 
# d5 <- eNorm_c1_long %>% 
# 
#   
# d6 <- eNorm_c2_long %>% 
# 
# 
# b5 <- eNorm_c1_long %>% 
# 
# 
# b6 <- eNorm_c2_long %>% 
# 
# 
#   
# ggarrange(b2, d2, b3, d3, b4, d4, b5, d5, b6, d6, nrow = 5, ncol = 2)

```

**What do you think is the interpretation of the normalized plots? i.e., What are the differences between the normalized and raw-filtered plots?**  



**Save the below objects**  

```{r save, eval=FALSE}
# 
# write_rds(eFil, )
# write_rds(eNorm_c1, )
# write_rds(eNorm_c2, )

```


End of Script  

***
